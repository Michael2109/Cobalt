:toc: macro
:toc-title:
:toclevels: 99

toc::[]

### Language Specification

{nbsp} +
{nbsp} +
{nbsp} +

#### Comments

Comments serve as program documentation. There are two forms:

. _Single line comments_ start with character `#` and stop at the end of the line
. _General comments_ start with character sequence `/\*` and end with first occurence of sequence `*/`

Comments can't be nested or start inside string literals. *TODO* how do comments behave (skip entirely, space, newline...)

#### Statements

##### Conditional statement

Conditional statements allow branching:
```
if Expression
  Statements
else
  Statements
```

To avoid deep nesting it is possible to use following shortened form:

```
if Expression
  Statements
else if Expression
  Statements
else
  Statements
```

Since statements in branches are indented, there is no ambiguity when deciding which `else` references which `if`.

*TODO* test `else if` and putting statements in line after expression (since there is no `:` as stated in the wiki it is necessary to check if it does not break the indentation or expr. parsing).

### Package declaration
*Package*
```
package dir.sub_dir
```
{nbsp} +
{nbsp} +
{nbsp} +

### Classes
*Class*
```
class Example
```

*Type parameter*
```
class Example[T]
```

*Constructor parameters*
```
class Example(a: Int, b: Int)
```

*Type parameter and constructor parameters*
```
class Example[T](a: Int, b; Int)
```

*Extend a parent class*
```
class Example extends ParentClass
```

*Implement a trait*
```
class Example extends ParentClass with TraitName
```
{nbsp} +
{nbsp} +
{nbsp} +

### Methods

*Inline*
```
add (a: Int, b: Int): Int = a + b
```

*Multi-line*
```
add (a: Int, b: Int): Int
  // Do something
  a + b
```

*Type inference*
```
add (a: Int, b: Int) = a + b
```
