:toc: macro
:toc-title:
:toclevels: 99

toc::[]

### Language Specification

{nbsp} +

### Comments
Single line comments
```
# This is a single line comment
```
Multiline Comment
```
/* This is a
   multiline
   comment */
```
Documentation comments
```
/**
 * Class Description
 * @param nameInit The persons name
 */
class Person(nameInit: String)

/** The age of the person **/
public
  val name:String = nameInit

/**
* Creates a greeting method for a perso
*
* @param otherPerson The person to greet
* @return the greeting message
*/
greet :: String -> String
greet otherPerson =
  "Hello $otherPerson"
```
{nbsp} +

#### Comments

Comments serve as program documentation. There are two forms:

. _Single line comments_ start with character `#` and stop at the end of the line
. _General comments_ start with character sequence `/\*` and end with first occurence of sequence `*/`

Comments can't be nested or start inside string literals. *TODO* how do comments behave (skip entirely, space, newline...)

#### Statements

##### Conditional statement

Conditional statements allow branching:
```
if Expression
  Statements
else
  Statements
```

To avoid deep nesting it is possible to use following shortened form:

```
if Expression
  Statements
else if Expression
  Statements
else
  Statements
```

Since statements in branches are indented, there is no ambiguity when deciding which `else` references which `if`.

*TODO* test `else if` and putting statements in line after expression (since there is no `:` as stated in the wiki it is necessary to check if it does not break the indentation or expr. parsing).

### Package declaration
Package
```
package dir.sub_dir
```
{nbsp} +

### Imports
Single import
```
import dir.subDir.ClassName
```
Multi import
```
import dir.subDir.{ClassName1, ClassName2}
```
Directory import
```
import dir.subDir.*
```
{nbsp} +

### Classes
Class
```
class Example
```

Type parameter
```
class Example[T]
```

Constructor parameters
```
class Example(a: Int, b: Int)
```

Type parameter and constructor parameters
```
class Example[T](a: Int, b; Int)
```

Extend a parent class
```
class Example extends ParentClass
```

Implement a trait
```
class Example extends ParentClass with TraitName
```
{nbsp} +

### Methods

Inline
```
add (a: Int, b: Int): Int = a + b
```

Multi-line
```
add (a: Int, b: Int): Int
  // Do something
  a + b
```

Type inference
```
add (a: Int, b: Int) = a + b
```
{nbsp} +

### Strings
Double quoted string
```
"This is a double quoted string"
```
{nbsp} +

### Print statements
Print
```
print ("Hello world!")
```
Print with new line
```
println ("Hello world!")
```
Print format
```
printf("Hello %s\n, "world")
```
{nbsp} +

### Defining values/variables
Value (Immutable)
```
val valName: ClassName = new ClassName()
```
Variable (Mutable)
```
var varName: ClassName = new ClassName()
```
Type inference
```
val x = 10              // Determines that x is an Int
val y = new ClassName() // Determines that y is a ClassName instance
```
{nbsp} +

### Modifiers
Modifiers for values/variables is defined after the class definition
```
public
  val x = "public"
  val y = 20
protected
  val z = "
```


{nbsp} +