module Main where

import Compiler
import JavaCompiler
import SymbolTable
import IOUtils

import System.Environment
import Control.Monad

main :: IO ()
main = do

    args <- getArgs
    options <- commandlineArgs args
    let isFileToCompile (FileToCompile _ ) = True
        isFileToCompile _ = False
    let isClassPath (ClassPath _ ) = True
        isClassPath _ = False
    let isDestinationDir (DestinationDir _ ) = True
        isDestinationDir _ = False
    let isHelpPresent = elem (Help) options
    let isVersionPresent = elem (Version) options
    let inputFiles = map (\(FileToCompile x) -> x) (filter isFileToCompile options)

    -- if multiple class paths or destination dirs are provided, first is taken instead of throwing error
    -- classpath is set to "cobalt_generated_java/" temporarly until we stop compiling to java. Original default was "./"
    let javaClasspath = (\(ClassPath cp) -> cp) . (defaultHead (ClassPath "cobalt_generated_java/")) $ filter isClassPath options
    let classOutputDir = (\(DestinationDir dd) -> dd) . (defaultHead (DestinationDir "cobalt_generated_classes/")) $ filter isDestinationDir options
    let javaOutputDir = "cobalt_generated_java/" -- only while we still compile to java

    when (isVersionPresent) printVersion
    when (isHelpPresent) printhelp
    if isHelpPresent
      then return ()
      else do
        checkIfTargetFilesSpecified inputFiles
        cleanDir (endsWith ".java") javaOutputDir

        putStrLn "Compiling - Cobalt -> Java"
        compile inputFiles javaOutputDir
        putStrLn "Complete."

        putStrLn "Compiling - Java -> Byte code"
        compileJavaDir javaClasspath javaOutputDir classOutputDir
        putStrLn "Complete."

        putStrLn "Executing generated Byte code"
        putStrLn "Unimplemented."

--not implemented yet
printVersion = return ()
printhelp = return ()
checkIfTargetFilesSpecified a = return ()
